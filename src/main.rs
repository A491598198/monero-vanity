// monero-vanity
//
// Copyright (c) 2022 hinto.janaiyo
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::{io,env,thread};
use std::io::Write;
use std::process::exit;
//use std::sync::{Arc, Mutex};
use std::time::{Instant,Duration};
use num_cpus;
use regex::Regex;
use rand::Rng;
use rand::rngs::OsRng;
use num_format::{Locale, ToFormattedString};
use monero::{PrivateKey,PublicKey,Address,Network,ViewPair,Hash};
use curve25519_dalek::scalar::Scalar;
use curve25519_dalek::constants::ED25519_BASEPOINT_TABLE;

fn main() {
	// Command arguments
	let args: Vec<String> = env::args().collect();
	if args.len() > 1 {
		if args[1] == "--benchmark" {
			test();
		}
	}

	// Title
	println!("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
	println!("@        monero-vanity        @");
	println!("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");

	// Ask user for thread count
	let detected_threads: u32 = num_cpus::get().try_into().unwrap();
	let mut input = String::new();
	let threads: u32;
	print!("How many threads to use? [0-{}] (0 = all threads): ", detected_threads);
	io::stdout().flush().unwrap();
	io::stdin().read_line(&mut input).expect("Failed read line");
	// Handle input
	let input: u32 = input.trim().parse().expect("Input was not a number");
	if input > detected_threads {
		println!("Input [{}] is greater than detected cores [{}]", input, detected_threads);
		exit(1);
	} else if input == 0 {
		threads = detected_threads;
	} else {
		threads = input;
	}
	println!("Using [{}] threads", threads);

	// Get safety level
	println!("");
	println!("What RNG safety level? [normal|safe]");
	println!("    - Normal: Private key is generated by reducing a 256-bit integer");
	println!("    - Safe (slower): Private key is generated from by reducing a 512-bit integer");
	print!("Safety level: ");
	io::stdout().flush().unwrap();
	let mut input = String::new();
	let safe;
	io::stdin().read_line(&mut input).expect("Failed read line");
	// Strip newline off input
	if input.ends_with('\n') {
		input.pop();
		if input.ends_with('\r') {
			input.pop();
		}
	}
	if Regex::is_match(&Regex::new("^(S|s).*$").unwrap(), &input) {
		safe = "safe";
	} else {
		safe = "normal";
	}
	println!("Safety mode: [{}]", safe);

	// Get match mode
	println!("");
	println!("What mode to use? [third|first|full]");
	println!("    - Third: matches 3rd-43rd character");
	println!("    - First: matches 1st-43rd character");
	println!("    - Full (6x SLOWER): matches full address, 1st-95th character");
	print!("Mode: ");
	io::stdout().flush().unwrap();
	let mut input = String::new();
	let mode;
	io::stdin().read_line(&mut input).expect("Failed read line");
	// Strip newline off input
	if input.ends_with('\n') {
		input.pop();
		if input.ends_with('\r') {
			input.pop();
		}
	}
	if Regex::is_match(&Regex::new("^(F|f)(U|u).*$").unwrap(), &input) {
		mode = "full";
	} else if Regex::is_match(&Regex::new("^(F|f).*$").unwrap(), &input) {
		mode = "first";
	} else {
		mode = "third";
	}
	println!("Using Mode: [{}]", mode);

	// Get address pattern
	println!("");
	println!("What pattern to look for?");
	println!("    - Must be ASCII or a Regex pattern");
	println!("    - Must not include 'I', 'O', 'l', '0', '+', '/' ");
	println!("    - [48hinto...] would match if \"^48hinto.*$\" was typed");
	println!("    - [44hinto...|48h1nto...] would match if \"^4(4|8)h(i|1)nto.*$\" was typed");
	println!("    - Rust regex patterns are used: https://docs.rs/regex/latest/regex ");
	print!("Pattern: ");
	io::stdout().flush().unwrap();
	let mut input = String::new();
	io::stdin().read_line(&mut input).expect("Failed read line");
	// Strip newline off input
	if input.ends_with('\n') {
		input.pop();
		if input.ends_with('\r') {
			input.pop();
		}
	}
	let pattern;
	if mode == "third" {
		pattern = format!("^..{}.*$", input);
	} else {
		pattern = format!("{}", input);
	}

	// RNG safety level
	let seed: Scalar;
	if safe == "safe" {
		let mut x = [0u8; 64];
		rand::thread_rng().fill(&mut x[..]);
		seed = Scalar::from_bytes_mod_order_wide(&x); // Random [u8; 64]
	} else {
		seed = Scalar::random(&mut OsRng); // Random [u8; 32]
	}

	// Print input values
	println!("");
	print!("Threads: [{}], Pattern: [{}], Type: [{}], Safety: [{}], working...", threads, Regex::new(&pattern).unwrap(), mode, safe);
	io::stdout().flush().unwrap();

	// Set runtime values
	let mut base = &seed * &ED25519_BASEPOINT_TABLE; // Base for all threads
	let offset = &Scalar::from(threads) * &ED25519_BASEPOINT_TABLE; // Offset depending on threads
	let mut tries = 0; // Interations
	let network = [18].as_ref(); // [18] = Mainnet
	let now = Instant::now(); // Set timer
	let locale = &Locale::en; // 1000 -> 1,000 formatter

	// Start [Full]
	if mode == "full" {
	for i in 1..=threads {
		let regex = Regex::new(&pattern).unwrap();
		thread::spawn(move|| {
			// Recalculate base with thread number
			base = base + (&Scalar::from(i) * &ED25519_BASEPOINT_TABLE);
			loop {
				// Compare [regex] == [Full address]
				if Regex::is_match(&regex, &Address::from_viewpair(Network::Mainnet, &ViewPair { view: Hash::hash_to_scalar((seed + Scalar::from(i) + Scalar::from(tries*threads)).as_bytes()), spend: PublicKey::from_slice(base.compress().as_bytes()).unwrap(), }).to_string()) {
					// If found, recover with: private_spend_key = original_seed + thread_id + (tries * threads)
					let priv_spend = PrivateKey { scalar: seed + Scalar::from(i) + Scalar::from(tries*threads), };
					let priv_view = Hash::hash_to_scalar((seed + Scalar::from(i) + Scalar::from(tries*threads)).as_bytes());
					let pub_spend = PublicKey::from_private_key(&priv_spend);
					let pub_view = PublicKey::from_private_key(&priv_view);
					let address = &Address::standard(Network::Mainnet, pub_spend, pub_view);
					let speed = ((tries as f64 / now.elapsed().as_secs_f64()) * threads as f64) as u64;
					println!("\n");
					println!("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
					println!("Tries: [{}], Seconds: [{}], Speed: [{} keys/sec]\n", (tries * threads).to_formatted_string(locale), now.elapsed().as_secs_f32(), speed.to_formatted_string(locale));
					println!("Private Spend Key | {}", priv_spend);
					println!("Private View Key  | {}", priv_view);
					println!("Public Spend Key  | {}", pub_spend);
					println!("Public View Key   | {}", pub_view);
					println!("Standard Address  | {}\n", address);
					println!("Recover with: monero-wallet-cli --generate-from-spend-key");
					println!("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
					exit(0);
				}
				tries += 1;
				base += offset;
			}
		});
	}
	// Else, start [Third/First]
	} else {
	for i in 1..=threads {
		let regex = Regex::new(&pattern).unwrap();
		thread::spawn(move|| {
			// Recalculate base with thread number
			base = base + (&Scalar::from(i) * &ED25519_BASEPOINT_TABLE);
			loop {
				// Compare [regex] == [1st half of Address via public spend key]
				if Regex::is_match(&regex, &base58_monero::encode(&[network, (base).compress().as_bytes()].concat()).unwrap()[..=43]) {
					// If found, recover with: private_spend_key = original_seed + thread_id + (tries * threads)
					let private = PrivateKey { scalar: seed + Scalar::from(i) + Scalar::from(tries*threads), };
					let address = &base58_monero::encode(&[network, (base).compress().as_bytes()].concat()).unwrap()[..=43];
					let speed = ((tries as f64 / now.elapsed().as_secs_f64()) * threads as f64) as u64;
					println!("\n");
					println!("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
					println!("Tries: [{}], Seconds: [{}], Speed: [{} keys/sec]\n", (tries * threads).to_formatted_string(locale), now.elapsed().as_secs_f32(), speed.to_formatted_string(locale));
				    println!("Private Spend Key | {}", private);
				    println!("Standard Address  | {}...\n", address);
					println!("Recover with: monero-wallet-cli --generate-from-spend-key");
					println!("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
					exit(0);
				}
				tries += 1;
				base += offset;
			}
		});
	}
	}
	thread::park();
}

fn test() {
	// Ask user for thread count
	let detected_threads: u32 = num_cpus::get().try_into().unwrap();
	let mut input = String::new();
	let threads: u32;
	println!("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
	println!("@ monero-vanity benchmark mode @");
	println!("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
	print!("How many threads to use? [0-{}] (0 = all threads): ", detected_threads);
	io::stdout().flush().unwrap();
	io::stdin().read_line(&mut input).expect("Failed read line");
	// Handle input
	let input: u32 = input.trim().parse().expect("Input was not a number");
	if input > detected_threads {
		println!("Input [{}] is greater than detected cores [{}]", input, detected_threads);
		exit(1);
	} else if input == 0 {
		threads = detected_threads;
	} else {
		threads = input;
	}

	// Ask user for interation count
	let mut input = String::new();
	let iter: u64;
	print!("How many interations? ");
	io::stdout().flush().unwrap();
	io::stdin().read_line(&mut input).expect("Failed read line");
	// Handle input
	let input: u64 = input.trim().parse().expect("Input was not a number");
	if input == 0 {
		iter = 1_000_000;
	} else {
		iter = input;
	}

	// Set runtime values
	let seed = Scalar::random(&mut OsRng); // Random [u8; 32]
	let mut base = &seed * &ED25519_BASEPOINT_TABLE; // Base for all threads
	let offset = &Scalar::from(threads) * &ED25519_BASEPOINT_TABLE; // Offset depending on threads
	let mut tries = 0; // Interations
	let network = [18].as_ref(); // [18] = Mainnet
	let now = Instant::now(); // Set timer
	let locale = &Locale::en; // 1000 formatter

	println!("Testing [{}] iterations on [{}] threads...\n", iter.to_formatted_string(locale), threads.to_formatted_string(locale));
	// Test
	for i in 1..=threads {
		thread::spawn(move|| {
			let regex = &Regex::new("^..l.*$").unwrap(); // impossible pattern
			base = base + (&Scalar::from(i) * &ED25519_BASEPOINT_TABLE);
			while tries != iter {
				if Regex::is_match(&regex, &base58_monero::encode(&[network, (base).compress().as_bytes()].concat()).unwrap()[..=43]) {
					println!("wtf");
					exit(1);
				}
				tries += 1;
				base += offset;
			}
			let speed = iter as f64 / now.elapsed().as_secs_f64();
			let full_speed = (speed * threads as f64) as u64;
			println!("Thread: [{}], Time: [{:?}], Speed: [{} keys/sec]", i, now.elapsed().as_secs_f32(), (speed as u64).to_formatted_string(locale));
			thread::sleep(Duration::from_millis(1000));
			println!("\nFull speed: [{} keys/sec]", full_speed.to_formatted_string(locale));
			exit(0);
		});
	}
	thread::park();
}
