// monero-vanity
//
// Copyright (c) 2022 hinto.janaiyo
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

use std::io;
use std::io::Write;
use std::thread;
use std::process::exit;
use std::time::Instant;
use num_cpus;
use regex::Regex;
use rand::Rng;
use rand::rngs::OsRng;
use monero::{PrivateKey,PublicKey,Address,Network,ViewPair};
use monero::cryptonote::hash::Hash;
use curve25519_dalek::scalar::Scalar;
use curve25519_dalek::constants::ED25519_BASEPOINT_TABLE;
fn main() {
	// Ask user for thread count
	let detected_threads: u32 = num_cpus::get().try_into().unwrap();
	let mut input = String::new();
	let threads: u32;
	print!("How many threads to use? [0-{}] (0 = all threads): ", detected_threads);
	io::stdout().flush().unwrap();
    io::stdin().read_line(&mut input).expect("Failed read line");
	// Handle input
	let input: u32 = input.trim().parse().expect("Input was not a number");
	if input > detected_threads {
		println!("Input [{}] is greater than detected cores [{}]", input, detected_threads);
		exit(1);
	} else if input == 0 {
		threads = detected_threads;
	} else {
		threads = input;
	}
	println!("Using [{}] threads", threads);

	// Get safety level
	println!("");
	println!("What RNG safety level? [normal|safe]");
	println!("    - Normal: Private key is generated by reducing a 256-bit integer");
	println!("    - Safe (slower): Private key is generated from by reducing a 512-bit integer");
	print!("Safety level: ");
	io::stdout().flush().unwrap();
	let mut input = String::new();
	let safe;
    io::stdin().read_line(&mut input).expect("Failed read line");
	// Strip newline off input
	if input.ends_with('\n') {
		input.pop();
		if input.ends_with('\r') {
			input.pop();
		}
	}
	if Regex::is_match(&Regex::new("^(S|s).*$").unwrap(), &input) {
		safe = "safe";
	} else {
		safe = "normal";
	}
	println!("Safety mode: [{}]", safe);

	// Get pattern type
	println!("");
	println!("What type to look for? [third|first|full]");
	println!("    - Third: matches 3rd-43rd character");
	println!("    - First: matches 1st-43rd character");
	println!("    - Full (SLOWER): matches full address, 1st-95th character");
	print!("Type: ");
	io::stdout().flush().unwrap();
	let mut input = String::new();
	let pattern_type;
    io::stdin().read_line(&mut input).expect("Failed read line");
	// Strip newline off input
	if input.ends_with('\n') {
		input.pop();
		if input.ends_with('\r') {
			input.pop();
		}
	}
	if Regex::is_match(&Regex::new("^(F|f)(U|u).*$").unwrap(), &input) {
		pattern_type = "full";
	} else if Regex::is_match(&Regex::new("^(F|f).*$").unwrap(), &input) {
		pattern_type = "first";
	} else {
		pattern_type = "third";
	}
	println!("Using type: [{}]", pattern_type);

	// Get address pattern
	println!("");
	println!("What pattern to look for?");
	println!("    - Must be ASCII or a Regex pattern");
	println!("    - Must not include 'I', 'O', 'l', '0', '+', '/' ");
	println!("    - [48hinto...] would match if \"^48hinto.*$\" was typed");
	println!("    - [44hinto...|48h1nto...] would match if \"^4(4|8)h(i|1)nto.*$\" was typed");
	println!("    - Rust regex patterns are used: https://docs.rs/regex/latest/regex ");
	print!("Pattern: ");
	io::stdout().flush().unwrap();
	let mut input = String::new();
    io::stdin().read_line(&mut input).expect("Failed read line");
	// Strip newline off input
	if input.ends_with('\n') {
		input.pop();
		if input.ends_with('\r') {
			input.pop();
		}
	}
	let pattern;
	if pattern_type == "third" {
		pattern = format!("^..{}.*$", input);
	} else {
		pattern = format!("{}", input);
	}

	// RNG safety level
	let seed: Scalar;
	if safe == "safe" {
		let mut x = [0u8; 64];
		rand::thread_rng().fill(&mut x[..]);
		seed = Scalar::from_bytes_mod_order_wide(&x); // Random [u8; 64]
	} else {
		seed = Scalar::random(&mut OsRng); // Random [u8; 32]
	}

	// Print input values
	println!("");
	print!("Threads: [{}], Pattern: [{}], Type: [{}], Safety: [{}], working...", threads, Regex::new(&pattern).unwrap(), pattern_type, safe);
	io::stdout().flush().unwrap();

	// Set runtime values
	let mut base = &seed * &ED25519_BASEPOINT_TABLE; // Base for all threads
	let offset = &Scalar::from(threads) * &ED25519_BASEPOINT_TABLE; // Offset depending on threads
	let mut tries = 0; // Interations
	let network = [18].as_ref(); // [18] = Mainnet
	let now = Instant::now(); // Set timer

	// Start [Full]
	if pattern_type == "full" {
	for i in 1..=threads {
		let regex = Regex::new(&pattern).unwrap();
		thread::spawn(move|| {
			// Recalculate base with thread number
			base = base + (&Scalar::from(i) * &ED25519_BASEPOINT_TABLE);
			loop {
				// Compare [regex] == [Full address]
				if Regex::is_match(&regex, &Address::from_viewpair(Network::Mainnet, &ViewPair { view: Hash::hash_to_scalar((seed + Scalar::from(i) + Scalar::from(tries*threads)).as_bytes()), spend: PublicKey::from_slice(base.compress().as_bytes()).unwrap(), }).to_string()) {
					// If found, recover with: private_spend_key = original_seed + thread_id + (tries * threads)
					let priv_spend = PrivateKey { scalar: seed + Scalar::from(i) + Scalar::from(tries*threads), };
					let priv_view = Hash::hash_to_scalar((seed + Scalar::from(i) + Scalar::from(tries*threads)).as_bytes());
					let pub_spend = PublicKey::from_private_key(&priv_spend);
					let pub_view = PublicKey::from_private_key(&priv_view);
					let address = &Address::standard(Network::Mainnet, pub_spend, pub_view);
					println!("\n");
					println!("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
					println!("Found in [{}] tries in [{:?}]!\n", tries * threads, now.elapsed());
					println!("Private Spend Key | {}", priv_spend);
					println!("Private View Key  | {}", priv_view);
					println!("Public Spend Key  | {}", pub_spend);
					println!("Public View Key   | {}", pub_view);
					println!("Standard Address  | {}\n", address);
					println!("Recover with: monero-wallet-cli --generate-from-spend-key");
					println!("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
					exit(0);
				}
				tries += 1;
				base += offset;
			}
		});
	}
	} else {
	for i in 1..=threads {
		let regex = Regex::new(&pattern).unwrap();
		thread::spawn(move|| {
			// Recalculate base with thread number
			base = base + (&Scalar::from(i) * &ED25519_BASEPOINT_TABLE);
			loop {
				// Compare [regex] == [1st half of Address via public spend key]
				if Regex::is_match(&regex, &base58_monero::encode(&[network, (base).compress().as_bytes()].concat()).unwrap()[..=43]) {
					// If found, recover with: private_spend_key = original_seed + thread_id + (tries * threads)
					let private = PrivateKey { scalar: seed + Scalar::from(i) + Scalar::from(tries*threads), };
					let address = &base58_monero::encode(&[network, (base).compress().as_bytes()].concat()).unwrap()[..=43];
					println!("\n");
					println!("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
					println!("Found in [{}] tries in [{:?}]!\n", tries * threads, now.elapsed());
				    println!("Private Spend Key | {}", private);
				    println!("Standard Address  | {}...\n", address);
					println!("Recover with: monero-wallet-cli --generate-from-spend-key");
					println!("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@");
					exit(0);
				}
				tries += 1;
				base += offset;
			}
		});
	}
	}
	thread::park();
}
